#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

/**
 * Converts camelCase to snake_case
 */
function camelToSnakeCase(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

const GENERATED_DIR = "ClientApp/src/Types";
const OUTPUT_FILE = "ClientApp/src/Types/generated.d.ts";

/**
 * Combines all generated TypeScript definition files into a single generated.d.ts
 */
function combineTypes() {
  console.log("üîÑ Combining TypeScript types into single generated.d.ts...");

  if (!fs.existsSync(GENERATED_DIR)) {
    console.error(`‚ùå Generated directory not found: ${GENERATED_DIR}`);
    process.exit(1);
  }

  // Read all .ts files except generated.d.ts and exclude all framework i-* types
  const files = fs
    .readdirSync(GENERATED_DIR)
    .filter(
      (file) =>
        file.endsWith(".ts") &&
        file !== "generated.d.ts" &&
        !file.includes("index")
    )
    .filter((file) => !file.startsWith("i-"))
    .sort();

  if (files.length === 0) {
    console.warn("‚ö†Ô∏è  No TypeScript files found in generated directory");
    return;
  }

  console.log(`üìÅ Found ${files.length} generated files:`, files.join(", "));

  let combinedContent = [];

  // Add header
  combinedContent.push(
    "/**",
    " * Auto-generated TypeScript definitions from .NET models",
    " * Generated by dotnet-typegen and combined by combine-types script",
    " * Do not edit this file manually - it will be regenerated",
    " */",
    ""
  );

  // Process each file
  for (const file of files) {
    const filePath = path.join(GENERATED_DIR, file);
    const content = fs.readFileSync(filePath, "utf8");

    console.log(`üìÑ Processing ${file}...`);

    // Remove TypeGen header comments and imports
    const lines = content.split("\n");
    const cleanLines = [];
    let inHeaderComment = false;
    let skipEmptyLines = true;

    for (const line of lines) {
      const trimmed = line.trim();

      // Skip TypeGen header comments
      if (trimmed.startsWith("/**")) {
        inHeaderComment = true;
        continue;
      }
      if (inHeaderComment && trimmed.endsWith("*/")) {
        inHeaderComment = false;
        continue;
      }
      if (inHeaderComment) {
        continue;
      }

      // Skip import statements (since we're combining everything)
      if (
        trimmed.startsWith("import ") ||
        trimmed.startsWith("export * from")
      ) {
        continue;
      }

      // Skip empty lines at the beginning
      if (skipEmptyLines && trimmed === "") {
        continue;
      }

      skipEmptyLines = false;

      // Convert camelCase property names to snake_case
      let convertedLine = line.replace(/(\w+):/g, (match, propName) => {
        return `${camelToSnakeCase(propName)}:`;
      });

      // Convert classes to interfaces and remove default values for better TS compatibility
      convertedLine = convertedLine.replace(
        /export class (\w+)/g,
        "export interface $1"
      );
      convertedLine = convertedLine.replace(/ = '[^']*'/g, ""); // Remove string defaults
      convertedLine = convertedLine.replace(/ = \d+/g, ""); // Remove number defaults
      convertedLine = convertedLine.replace(/ = (true|false)/g, ""); // Remove boolean defaults

      cleanLines.push(convertedLine);
    }

    // Add the cleaned content
    if (cleanLines.length > 0) {
      const title = file
        .replace(".ts", "")
        .split("-")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");

      // Special handling for InertiaSharedProps to make it a generic type
      if (title === "Inertia Shared Props") {
        // Extract properties from the generated interface
        const interfaceProperties = [];
        let inInterface = false;

        for (const line of cleanLines) {
          const trimmed = line.trim();
          if (trimmed.startsWith("export interface InertiaSharedProps")) {
            inInterface = true;
            continue;
          }
          if (inInterface && trimmed === "}") {
            break;
          }
          if (inInterface && trimmed && !trimmed.startsWith("//")) {
            interfaceProperties.push(line);
          }
        }

        combinedContent.push(
          `// ${title}`,
          `export type InertiaSharedProps<T = Record<string, unknown>> = T & {`,
          ...interfaceProperties,
          `  [key: string]: unknown;`,
          `};`,
          ""
        );
      } else {
        combinedContent.push(`// ${title}`, ...cleanLines, "");
      }
    }
  }

  // Write the combined file
  const outputContent = combinedContent.join("\n");

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, outputContent);

  // Clean up individual files after combining
  console.log("üßπ Cleaning up individual type files...");
  for (const file of files) {
    const filePath = path.join(GENERATED_DIR, file);
    fs.unlinkSync(filePath);
    console.log(`üóëÔ∏è  Removed ${file}`);
  }

  console.log(`‚úÖ Successfully combined types into ${OUTPUT_FILE}`);
  console.log(`üìä Generated file contains ${combinedContent.length} lines`);

  // Show a preview of what was generated
  const preview = outputContent.split("\n").slice(0, 20).join("\n");
  console.log("\nüìã Preview:");
  console.log("‚îÄ".repeat(50));
  console.log(preview);
  if (combinedContent.length > 20) {
    console.log("...");
  }
  console.log("‚îÄ".repeat(50));
}

// Run the script
try {
  combineTypes();
} catch (error) {
  console.error("‚ùå Error combining types:", error.message);
  process.exit(1);
}
