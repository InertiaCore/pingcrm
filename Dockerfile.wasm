# Multi-stage Dockerfile for compiling .NET to WASM for Cloudflare Workers
# Stage 1: Build frontend assets
FROM node:24-alpine AS frontend-build

WORKDIR /src/ClientApp

# Copy package files and install dependencies
COPY ClientApp/package*.json ./
RUN npm ci

# Copy frontend source and build for production
COPY ClientApp/ ./
RUN npm run build

# Debug: List what was created
RUN ls -la dist/ || echo "No dist directory"

# Stage 2: Build .NET application to WASM
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS wasm-build

# Install Python (required for emscripten) and WASM workloads
RUN apt-get update && apt-get install -y python3 python3-pip && \
    ln -s /usr/bin/python3 /usr/bin/python

# Install WASM workloads and tools
RUN dotnet workload install wasm-tools

WORKDIR /src

# Create empty wwwroot for now (static files will be handled by Cloudflare)
RUN mkdir -p wwwroot

# Create minimal WASM project that only includes what we need
RUN echo '<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">' > PingCRM.Wasm.csproj && \
    echo '  <PropertyGroup>' >> PingCRM.Wasm.csproj && \
    echo '    <TargetFramework>net8.0</TargetFramework>' >> PingCRM.Wasm.csproj && \
    echo '    <Nullable>enable</Nullable>' >> PingCRM.Wasm.csproj && \
    echo '    <ImplicitUsings>enable</ImplicitUsings>' >> PingCRM.Wasm.csproj && \
    echo '    <BlazorEnableTimeZoneSupport>false</BlazorEnableTimeZoneSupport>' >> PingCRM.Wasm.csproj && \
    echo '    <BlazorEnableCompression>false</BlazorEnableCompression>' >> PingCRM.Wasm.csproj && \
    echo '    <RunAOTCompilation>false</RunAOTCompilation>' >> PingCRM.Wasm.csproj && \
    echo '    <PublishTrimmed>false</PublishTrimmed>' >> PingCRM.Wasm.csproj && \
    echo '    <InvariantGlobalization>true</InvariantGlobalization>' >> PingCRM.Wasm.csproj && \
    echo '    <WasmGenerateAppBundle>false</WasmGenerateAppBundle>' >> PingCRM.Wasm.csproj && \
    echo '    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>' >> PingCRM.Wasm.csproj && \
    echo '  </PropertyGroup>' >> PingCRM.Wasm.csproj && \
    echo '  <ItemGroup>' >> PingCRM.Wasm.csproj && \
    echo '    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="8.0.0" />' >> PingCRM.Wasm.csproj && \
    echo '    <PackageReference Include="System.Text.Json" Version="8.0.0" />' >> PingCRM.Wasm.csproj && \
    echo '    <PackageReference Include="Microsoft.Extensions.Hosting" Version="8.0.0" />' >> PingCRM.Wasm.csproj && \
    echo '    <PackageReference Include="Microsoft.Extensions.Http" Version="8.0.0" />' >> PingCRM.Wasm.csproj && \
    echo '    <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />' >> PingCRM.Wasm.csproj && \
    echo '  </ItemGroup>' >> PingCRM.Wasm.csproj && \
    echo '</Project>' >> PingCRM.Wasm.csproj

# Copy only the WASM-specific source files (no controllers, models, etc.)
COPY Program.Wasm.cs ./Program.cs

# Create simplified SharedTypes without TypeGen dependencies
RUN echo 'namespace PingCRM.ViewModels.Shared;' > SharedTypes.cs && \
    echo 'public class UserDto { public int Id { get; set; } public string FirstName { get; set; } = ""; public string LastName { get; set; } = ""; public string Email { get; set; } = ""; public bool Owner { get; set; } public AccountDto? Account { get; set; } }' >> SharedTypes.cs && \
    echo 'public class AccountDto { public int Id { get; set; } public string Name { get; set; } = ""; }' >> SharedTypes.cs && \
    echo 'public class AuthDto { public UserDto? User { get; set; } }' >> SharedTypes.cs && \
    echo 'public class FlashDto { public string? Error { get; set; } public string? Success { get; set; } }' >> SharedTypes.cs && \
    echo 'public class InertiaSharedProps { public required AuthDto Auth { get; set; } public FlashDto? Flash { get; set; } }' >> SharedTypes.cs

# Create minimal data models for WASM (without EF dependencies)
RUN echo 'namespace PingCRM.Models;' > Models.cs && \
    echo 'public class User { public int Id { get; set; } public string FirstName { get; set; } = ""; public string LastName { get; set; } = ""; public string Email { get; set; } = ""; public bool Owner { get; set; } }' >> Models.cs && \
    echo 'public class LoginRequest { public string Email { get; set; } = ""; public string Password { get; set; } = ""; public bool Remember { get; set; } }' >> Models.cs

# Restore and build with simplified settings
RUN dotnet restore PingCRM.Wasm.csproj
RUN dotnet publish PingCRM.Wasm.csproj \
    -c Release \
    -o /app/publish \
    --no-restore

# Stage 3: Create Cloudflare Worker package
FROM node:24-alpine AS worker-build

WORKDIR /worker

# Install Cloudflare Workers CLI and tools
RUN npm install -g wrangler @cloudflare/workers-types

# Copy WASM output
COPY --from=wasm-build /app/publish ./dist

# Create worker configuration and entry point
RUN echo 'name = "pingcrm-worker"' > wrangler.toml && \
    echo 'main = "src/worker.js"' >> wrangler.toml && \
    echo 'compatibility_date = "2024-01-01"' >> wrangler.toml && \
    echo 'compatibility_flags = ["nodejs_compat"]' >> wrangler.toml && \
    echo '' >> wrangler.toml && \
    echo '[build]' >> wrangler.toml && \
    echo 'command = "echo Build complete"' >> wrangler.toml && \
    echo '' >> wrangler.toml && \
    echo '[vars]' >> wrangler.toml && \
    echo 'ENVIRONMENT = "production"' >> wrangler.toml && \
    echo 'DATABASE_PROVIDER = "Sqlite"' >> wrangler.toml && \
    echo '' >> wrangler.toml && \
    echo '[[kv_namespaces]]' >> wrangler.toml && \
    echo 'binding = "PINGCRM_KV"' >> wrangler.toml && \
    echo 'id = "your-kv-namespace-id"' >> wrangler.toml && \
    echo 'preview_id = "your-preview-kv-namespace-id"' >> wrangler.toml

# Create worker entry point
RUN mkdir -p src && \
    echo 'import { DotNet } from "./dist/_framework/dotnet.js";' > src/worker.js && \
    echo '' >> src/worker.js && \
    echo 'export default {' >> src/worker.js && \
    echo '  async fetch(request, env, ctx) {' >> src/worker.js && \
    echo '    try {' >> src/worker.js && \
    echo '      // Initialize .NET runtime' >> src/worker.js && \
    echo '      const { getAssemblyExports, getConfig } = await DotNet.create();' >> src/worker.js && \
    echo '      ' >> src/worker.js && \
    echo '      // Get the main assembly exports' >> src/worker.js && \
    echo '      const config = getConfig();' >> src/worker.js && \
    echo '      const exports = await getAssemblyExports(config.mainAssemblyName);' >> src/worker.js && \
    echo '      ' >> src/worker.js && \
    echo '      // Handle HTTP request through .NET' >> src/worker.js && \
    echo '      const url = new URL(request.url);' >> src/worker.js && \
    echo '      const method = request.method;' >> src/worker.js && \
    echo '      const headers = Object.fromEntries(request.headers);' >> src/worker.js && \
    echo '      const body = method !== "GET" && method !== "HEAD" ? await request.text() : null;' >> src/worker.js && \
    echo '      ' >> src/worker.js && \
    echo '      // Call .NET HTTP handler' >> src/worker.js && \
    echo '      const response = await exports.MyApp.HandleHttpRequest(' >> src/worker.js && \
    echo '        method,' >> src/worker.js && \
    echo '        url.pathname + url.search,' >> src/worker.js && \
    echo '        JSON.stringify(headers),' >> src/worker.js && \
    echo '        body || ""' >> src/worker.js && \
    echo '      );' >> src/worker.js && \
    echo '      ' >> src/worker.js && \
    echo '      // Parse .NET response' >> src/worker.js && \
    echo '      const responseData = JSON.parse(response);' >> src/worker.js && \
    echo '      ' >> src/worker.js && \
    echo '      return new Response(responseData.body, {' >> src/worker.js && \
    echo '        status: responseData.statusCode,' >> src/worker.js && \
    echo '        headers: responseData.headers' >> src/worker.js && \
    echo '      });' >> src/worker.js && \
    echo '      ' >> src/worker.js && \
    echo '    } catch (error) {' >> src/worker.js && \
    echo '      console.error("Worker error:", error);' >> src/worker.js && \
    echo '      return new Response("Internal Server Error", { status: 500 });' >> src/worker.js && \
    echo '    }' >> src/worker.js && \
    echo '  }' >> src/worker.js && \
    echo '};' >> src/worker.js

# Create package.json for the worker
RUN echo '{' > package.json && \
    echo '  "name": "pingcrm-worker",' >> package.json && \
    echo '  "version": "1.0.0",' >> package.json && \
    echo '  "description": "PingCRM running on Cloudflare Workers via WASM",' >> package.json && \
    echo '  "main": "src/worker.js",' >> package.json && \
    echo '  "scripts": {' >> package.json && \
    echo '    "dev": "wrangler dev",' >> package.json && \
    echo '    "deploy": "wrangler deploy",' >> package.json && \
    echo '    "publish": "wrangler deploy --compatibility-date=2024-01-01"' >> package.json && \
    echo '  },' >> package.json && \
    echo '  "devDependencies": {' >> package.json && \
    echo '    "@cloudflare/workers-types": "^4.20240529.0",' >> package.json && \
    echo '    "wrangler": "^3.57.1"' >> package.json && \
    echo '  }' >> package.json && \
    echo '}' >> package.json

# Install worker dependencies
RUN npm install

# Create deployment instructions
RUN echo '# Cloudflare Worker Deployment Instructions' > README.md && \
    echo '' >> README.md && \
    echo '## Prerequisites' >> README.md && \
    echo '1. Install Cloudflare Wrangler CLI: `npm install -g wrangler`' >> README.md && \
    echo '2. Login to Cloudflare: `wrangler auth login`' >> README.md && \
    echo '3. Create KV namespace: `wrangler kv:namespace create "PINGCRM_KV"`' >> README.md && \
    echo '4. Update wrangler.toml with your KV namespace IDs' >> README.md && \
    echo '' >> README.md && \
    echo '## Local Development' >> README.md && \
    echo '```bash' >> README.md && \
    echo 'npm run dev' >> README.md && \
    echo '```' >> README.md && \
    echo '' >> README.md && \
    echo '## Deploy to Cloudflare Workers' >> README.md && \
    echo '```bash' >> README.md && \
    echo 'npm run deploy' >> README.md && \
    echo '```' >> README.md && \
    echo '' >> README.md && \
    echo '## Environment Variables' >> README.md && \
    echo 'Set these in your Cloudflare Workers dashboard:' >> README.md && \
    echo '- `DATABASE_PROVIDER`: Database provider (Sqlite, etc.)' >> README.md && \
    echo '- `DATABASE_CONNECTION_STRING`: Connection string for your database' >> README.md && \
    echo '' >> README.md && \
    echo '## Storage' >> README.md && \
    echo 'This worker uses Cloudflare KV for data storage. For SQLite,' >> README.md && \
    echo 'consider using Cloudflare D1 database instead.' >> README.md

# Stage 4: Output stage for local extraction
FROM alpine:latest AS output

# Copy worker artifacts to a standard location
COPY --from=worker-build /worker /output

# Create extraction script
RUN echo '#!/bin/sh' > /extract.sh && \
    echo 'echo "Copying Cloudflare Worker files to host..."' >> /extract.sh && \
    echo 'cp -r /output/* /host/' >> /extract.sh && \
    echo 'echo "Files copied successfully to ./wasm-output/"' >> /extract.sh && \
    echo 'echo "Run: cd wasm-output && npx wrangler deploy"' >> /extract.sh && \
    chmod +x /extract.sh

# Metadata
LABEL description="PingCRM compiled to WebAssembly for Cloudflare Workers"
LABEL version="1.0.0"
LABEL maintainer="PingCRM Team"

# The image contains everything needed to deploy to Cloudflare Workers